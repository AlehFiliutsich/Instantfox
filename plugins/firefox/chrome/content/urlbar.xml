<?xml version="1.0" encoding="UTF-8"?>

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="urlbar" extends="chrome://browser/content/urlbarBindings.xml#urlbar">
    <content sizetopopup="pref">
      <xul:hbox anonid="textbox-container"
                class="autocomplete-textbox-container urlbar-textbox-container"
                flex="1" xbl:inherits="focused">
        <children includes="image|deck|stack|box">
          <xul:image class="autocomplete-icon" allowevents="true"/>
        </children>
		<xul:stack class="urlbar-stack" flex="1">
			<xul:vbox class="urlbar-progress-layer" xbl:inherits="pack=pmpack" flex="1">
			  <children includes="progressmeter"/>
			</xul:vbox>
			<xul:hbox class="instantfox-box" align='center'>
			  <xul:hbox anonid="instantFoxKey" class="instantfox-key"><html:div/></xul:hbox>
			  <xul:hbox anonid="instantFoxSpacer" class="instantfox-spacer"><html:div/></xul:hbox>
			  <xul:hbox anonid="instantFoxShadow" class="instantfox-shadow"><html:div/></xul:hbox>
			</xul:hbox>
			<xul:hbox anonid="textbox-input-box"
					  class="textbox-input-box urlbar-input-box"
					  flex="1" xbl:inherits="tooltiptext=inputtooltiptext">
			  <children/>
			  <html:input anonid="input" flex="1"
						  class="autocomplete-textbox urlbar-input textbox-input uri-element-right-align"
						  allowevents="true"
						  xbl:inherits="tooltiptext=inputtooltiptext,onfocus,onblur,value,type,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey"/>
			</xul:hbox>
			<xul:hbox class='instantfox-box' align='center' pack='end' onclick='HH.openHelp()'>
				<xul:hbox class='instantfox-tip'><html:div/></xul:hbox>
			</xul:hbox>
		</xul:stack>
        <children includes="hbox"/>
      </xul:hbox>
      <xul:dropmarker anonid="historydropmarker"
                      class="autocomplete-history-dropmarker urlbar-history-dropmarker"
                      allowevents="true"
                      xbl:inherits="open,enablehistory,parentfocused=focused"/>
      <xul:popupset anonid="popupset"
                    class="autocomplete-result-popupset"/>
      <children includes="toolbarbutton"/>
    </content>

    <implementation implements="nsIDOMEventListener, nsIObserver">
	  <constructor><![CDATA[  //nsIDOMEventListener,
		setTimeout(this.InsertShadowStyle, 1000)
	  ]]></constructor>


      <field name="inputBox">
        document.getAnonymousElementByAttribute(this, "anonid", "textbox-input-box");
      </field>
      <field name="inputBoxInner">
        document.getAnonymousElementByAttribute(this, "anonid", "textbox-input-box-inner");
      </field>

	  <field name="instantFoxShadowNode">
        document.getAnonymousElementByAttribute(this, "anonid", "instantFoxShadow").firstChild;
      </field>
	  <field name="instantFoxSpacerNode">
        document.getAnonymousElementByAttribute(this, "anonid", "instantFoxSpacer").firstChild;
      </field>
	  <field name="instantFoxKeyNode">
        document.getAnonymousElementByAttribute(this, "anonid", "instantFoxKey").firstChild;
      </field>
	  <field name="instantFoxTipNode">
        document.getAnonymousElementByAttribute(this, "class", "instantfox-tip").firstChild;
      </field>

	  <method name="showTip">
        <parameter name="aURL"/>
        <body><![CDATA[
			this.instantFoxTipNode.parentNode.hidden=false
			this.instantFoxTipNode.textContent = aURL;
        ]]></body>
      </method>

	  <method name="InsertShadowStyle">
        <body><![CDATA[
			var boxStyle = document.getAnonymousElementByAttribute(gURLBar, "class", "instantfox-box").style;
			var compStyle = getComputedStyle(gURLBar.inputBox,'')
			boxStyle.marginLeft = compStyle.marginLeft
			boxStyle.marginRight = compStyle.marginRight
			// 1px is from getComputedStyle(gURLBar.mInputField.editor.rootElement).paddingLeft
			// this is platform independant.
			boxStyle.paddingLeft = '1px'
			boxStyle.paddingRight = '1px'
			/**/
        ]]></body>
      </method>
    </implementation>

  </binding>


  <binding id="autocomplete-richlistitem" extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">
    <content>
      <xul:hbox align="center" class="ac-title-box">
        <xul:image xbl:inherits="src=image" class="ac-site-icon"/>
        <xul:hbox anonid="title-box" class="ac-title" flex="1">
          <xul:description anonid="title" class="ac-normal-text ac-comment" xbl:inherits="selected"/>
        </xul:hbox>
        <xul:hbox anonid="extra-box" class="ac-extra" align="center" hidden="true">
          <xul:image class="ac-result-type-tag"/>
          <xul:label class="ac-normal-text ac-comment" xbl:inherits="selected" value=":"/>
          <xul:description anonid="extra" class="ac-normal-text ac-comment" xbl:inherits="selected"/>
        </xul:hbox>
        <xul:image anonid="type-image" class="ac-type-icon"/>
      </xul:hbox>
    </content>
    <implementation implements="nsIDOMXULSelectControlItemElement">
      <constructor>
        <![CDATA[
            this._typeImage = document.getAnonymousElementByAttribute(this, "anonid", "type-image");

            this._titleBox = document.getAnonymousElementByAttribute(this, "anonid", "title-box");
            this._title = document.getAnonymousElementByAttribute(this, "anonid", "title");

            this._extraBox = document.getAnonymousElementByAttribute(this, "anonid", "extra-box");
            this._extra = document.getAnonymousElementByAttribute(this, "anonid", "extra");

            this._adjustAcItem();
          ]]>
      </constructor>

      <property name="label" readonly="true">
        <getter>
          <![CDATA[
            var title = this.getAttribute("title");
            var url = this.getAttribute("url");

		   dump(title, url)
            return title + " " + url;
          ]]>
        </getter>
      </property>


      <method name="_getBoundaryIndices">
        <parameter name="aText"/>
        <parameter name="aSearchTokens"/>
        <body>
          <![CDATA[
		  //dump(aText, aSearchTokens)
          if (aSearchTokens == "")
            return [0, aText.length];

          // Find which regions of text match the search terms
          let regions = [];
          for each (let search in aSearchTokens) {
            let matchIndex;
            let startIndex = 0;
            let searchLen = search.length;

            // Find all matches of the search terms, but stop early for perf
            let lowerText = aText.toLowerCase().substr(0, this.boundaryCutoff);
            while ((matchIndex = lowerText.indexOf(search, startIndex)) >= 0) {
              // Start the next search from where this one finished
              startIndex = matchIndex + searchLen;
              regions.push([matchIndex, startIndex]);
            }
          }

          // Sort the regions by start position then end position
          regions = regions.sort(function(a, b) let (start = a[0] - b[0])
            start == 0 ? a[1] - b[1] : start);

          // Generate the boundary indices from each region
          let start = 0;
          let end = 0;
          let boundaries = [];
          let len = regions.length;
          for (let i = 0; i < len; i++) {
            // We have a new boundary if the start of the next is past the end
            let region = regions[i];
            if (region[0] > end) {
              // First index is the beginning of match
              boundaries.push(start);
              // Second index is the beginning of non-match
              boundaries.push(end);

              // Track the new region now that we've stored the previous one
              start = region[0];
            }

            // Push back the end index for the current or new region
            end = Math.max(end, region[1]);
          }

          // Add the last region
          boundaries.push(start);
          boundaries.push(end);

          // Put on the end boundary if necessary
          if (end < aText.length)
            boundaries.push(aText.length);

          // Skip the first item because it's always 0
          return boundaries.slice(1);
          ]]>
        </body>
      </method>

      <method name="_getSearchTokens">
        <parameter name="aSearch"/>
        <body>
          <![CDATA[
          let search = aSearch.toLowerCase();
		 // dump(aSearch)
		  if(search[0]=='`'){
		    var i = search.indexOf(' ')
			if(i==-1)i=search.length
		    return [search.slice(1, i)]
		  }
		  search = search.split(/\s+/)
		  if(InstantFoxModule.currentQuery)
			search.shift()
          return search;
          ]]>
        </body>
      </method>

      <method name="_setUpDescription">
        <parameter name="aDescriptionElement"/>
        <parameter name="aText"/>
        <parameter name="aNoEmphasis"/>
        <body>
          <![CDATA[
          // Get rid of all previous text
          while (aDescriptionElement.hasChildNodes())
            aDescriptionElement.removeChild(aDescriptionElement.firstChild);


          // Get the indices that separate match and non-match text
          let search = this.getAttribute("text");
          let tokens = this._getSearchTokens(search);
          let indices = this._getBoundaryIndices(aText, tokens);

          // If we're searching for something that needs alternate emphasis,
          // we'll need to check the text that we match
          //let checkAlt = this._needsAlternateEmphasis(search);

          let next;
          let start = 0;
          let len = indices.length;
          // Even indexed boundaries are matches, so skip the 0th if it's empty
          for (let i = indices[0] == 0 ? 1 : 0; i < len; i++) {
            next = indices[i];
            let text = aText.substr(start, next - start);
            start = next;

            if (i % 2 == 0) {
              // Emphasize the text for even indices
              let span = aDescriptionElement.appendChild(
                document.createElementNS("http://www.w3.org/1999/xhtml", "span"));
              span.className = "InstantFoxSuggest ac-emphasize-text";
              span.textContent = text;
            } else {
              // Otherwise, it's plain text
              aDescriptionElement.appendChild(document.createTextNode(text));
            }
          }
          ]]>
        </body>
      </method>

      <method name="_adjustAcItem">
        <body>
          <![CDATA[
          var title = this.getAttribute("title");

          var url = this.getAttribute("url");
		  if (url)
			this._setUpDescription(this._title, title);
		  return;
          ]]>
        </body>
      </method>


    </implementation>
	<handlers>
      <handler event="mouseup">
        <![CDATA[
		// var q=InstantFoxModule.currentQuery
		var search = this.getAttribute("title")

		InstantFox.onEnter(search, event.ctrlKey||event.altKey||event.metaKey)
        event.preventDefault()
		event.stopPropagation()
      ]]>
      </handler>
    </handlers>
  </binding>
  
   <binding id="splitmenu" extends="chrome://global/content/bindings/menu.xml#menuitem-base">
    <content align='stretch'>
		<xul:hbox anonid="item" flex="1" allowevents='true'>
			<xul:menuitem anonid="menuitem" flex="1"
                    class="menuitem-iconic-tooltip menuitem-iconic split-menuitem-item"
                    xbl:inherits="label,key,image,value,closemenu,disabled" />
        </xul:hbox>
		<xul:hbox anonid="menu" xbl:inherits="_moz-menuactive" allowevents='true' class="split-menu-right-image" >
            <xul:hbox align="center" class="menu-right" xbl:inherits="_moz-menuactive,disabled" style='pointer-events:none'>
                <xul:image/>
            </xul:hbox>
        </xul:hbox>
        <children includes="menupopup"/>
    </content>

    <implementation implements="nsIDOMXULSelectControlItemElement, nsIDOMXULContainerItemElement, nsIAccessibleProvider">
      
      <field name="item" readonly="true">
            document.getAnonymousElementByAttribute(this, "anonid", "item");
      </field>
      <field name="menuitem" readonly="true">
            document.getAnonymousElementByAttribute(this, "anonid", "menuitem");
      </field>
      <field name="menu" readonly="true">
            document.getAnonymousElementByAttribute(this, "anonid", "menu");
      </field>
      <property name="isMenuitemActive">
        <getter><![CDATA[            
            return this.menuitem.hasAttribute("_moz-menuactive")
        ]]></getter>
      </property>
      
    </implementation>
	<handlers>
      <handler event="mouseover" phase="target"><![CDATA[
      //this.menuitem.setAttribute("_moz-menuactive", true)
      if(event.target!=this||event.originalTarget==this)  
        return
      if(event.originalTarget==this.menu){
          this.menu.style.pointerEvents="none"
          this.menuitem.removeAttribute("_moz-menuactive")
          this.item.style.pointerEvents="" 
      }else if(event.originalTarget==this.item){
          if(this.hasAttribute("_moz-menuactive"))
            this.menuitem.setAttribute("_moz-menuactive", true)
          this.menu.style.pointerEvents=""
          this.item.style.pointerEvents="none"
      }
      ]]></handler>
      <handler event="mouseout" phase="target"><![CDATA[  
      if(event.originalTarget==this){
        this.menuitem.removeAttribute("_moz-menuactive")
        this.item.style.pointerEvents="" 
      }
      ]]></handler>
      <handler event="DOMMenuItemInactive" phase="target"><![CDATA[
        this.menuitem.setAttribute("_moz-menuactive", false)
      ]]></handler>
      <handler event="DOMMenuItemActive" phase="target"><![CDATA[
        if(this.item.style.pointerEvents=="none")
            this.menuitem.setAttribute("_moz-menuactive", true)
      ]]></handler>
	  <handler event="click" phase="target"><![CDATA[
			event.button != 1 && this.isMenuitemActive && this.parentNode.hidePopup();
      ]]></handler>
	  </handlers>
  </binding>
</bindings>