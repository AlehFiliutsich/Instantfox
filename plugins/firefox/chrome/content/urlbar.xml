<?xml version="1.0" encoding="UTF-8"?>

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="urlbar" extends="chrome://browser/content/urlbarBindings.xml#urlbar">
    <content sizetopopup="pref">
      <xul:hbox class="autocomplete-textbox-container urlbar-textbox-container" flex="1">
        <xul:stack flex="1">
          <children includes="progressmeter"/>
          <xul:hbox class="autocomplete-textbox-container-fission">
        <xul:hbox class="textbox-icon-box"
                  onmouseover="gURLBar._iconWasHovered = true;">
          <children includes="image|deck|stack|box">
            <xul:image class="autocomplete-icon" allowevents="true"/>
          </children>
        </xul:hbox>

        <xul:stack flex="1" anonid="textbox-input-box" class="textbox-input-box urlbar-input-box">
		  <xul:hbox class="textbox-input-box urlbar-input-box">
			  <xul:label anonid="instantFoxSpacer" class="instantfox-spacer urlbar-input textbox-input uri-element-right-align"/>		
			  <xul:label anonid="instantFoxShaddow"
						flex="1"
						onmousedown="gURLBar.focus();"
						ondragover="nsDragAndDrop.dragOver(event, gURLBar);"
						ondragdrop="nsDragAndDrop.drop(event, gURLBar);"
						ondragexit="nsDragAndDrop.dragExit(event, gURLBar);"
						class="instantfox-shaddow urlbar-input textbox-input uri-element-right-align" />
		  </xul:hbox>		
		  <xul:hbox anonid="textbox-input-box-inner" xbl:inherits="tooltiptext=inputtooltiptext"
                    flex="1" align="center">
            <children/>
            <html:input anonid="input" class="autocomplete-textbox urlbar-input textbox-input uri-element-right-align"
                        flex="1" allowevents="true"
                        xbl:inherits="tooltiptext=inputtooltiptext,onfocus,onblur,value,type,maxlength,disabled,size,readonly,placeholder,userAction"/>
		  </xul:hbox>
        </xul:stack>

        <children includes="hbox"/>
          </xul:hbox>
        </xul:stack>
      </xul:hbox>

      <xul:dropmarker anonid="historydropmarker"
                      class="autocomplete-history-dropmarker urlbar-history-dropmarker"
                      allowevents="true"
                      xbl:inherits="open,enablehistory,parentfocused=focused"/>

      <children includes="toolbarbutton"/>

      <xul:popupset anonid="popupset" class="autocomplete-result-popupset"/>
    </content>

    <implementation implements="nsIDOMEventListener, nsIObserver">

      <field name="uri"/>
      <field name="_focused"/>
      <field name="_mouseover"/>
      <field name="_iconWasHovered"/>
      <field name="_tooltipTimer"/>
	  
      <field name="inputBox">
        document.getAnonymousElementByAttribute(this, "anonid", "textbox-input-box");
      </field>
      <field name="inputBoxInner">
        document.getAnonymousElementByAttribute(this, "anonid", "textbox-input-box-inner");
      </field>
	  
	  <field name="instantFoxShaddowNode">
        document.getAnonymousElementByAttribute(this, "anonid", "instantFoxShaddow");
      </field>  
	  <field name="instantFoxSpacerNode">
        document.getAnonymousElementByAttribute(this, "anonid", "instantFoxSpacer");
      </field>  

	  <method name="InsertShaddowLink">
        <parameter name="aURL"/>
        <body><![CDATA[
			//if(aURL){
			this.instantFoxShaddowNode.value = aURL;
			//}
        ]]></body>
      </method> 
	  <method name="InsertSpacerLink">
        <parameter name="aURL"/>
        <body><![CDATA[
			if(aURL){
				this.instantFoxSpacerNode.value = aURL;
			}
        ]]></body>
      </method> 
	  <method name="InsertShaddowStyle">
        <parameter name="px"/>
        <body><![CDATA[
			if(px){
				this.instantFoxShaddowNode.style.cssText += "margin: "+px+" !important;";
			}
        ]]></body>
      </method>
	  <method name="InsertShaddowStyleStart">
        <parameter name="start"/>
        <body><![CDATA[
			if(start){
				this.instantFoxShaddowNode.style.cssText += "-moz-margin-start:  "+start+" !important;";
			}
        ]]></body>
      </method>        
    </implementation>

  </binding>


  <binding id="autocomplete-richlistitem" extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">
    <content>
      <xul:hbox align="center" class="ac-title-box">
        <xul:image xbl:inherits="src=image" class="ac-site-icon"/>
        <xul:hbox anonid="title-box" class="ac-title" flex="1"
                  onunderflow="_doUnderflow('_title');"
                  onoverflow="_doOverflow('_title');">
          <xul:description anonid="title" class="ac-normal-text ac-comment" xbl:inherits="selected"/>
        </xul:hbox>
        <xul:hbox anonid="extra-box" class="ac-extra" align="center" hidden="true">
          <xul:image class="ac-result-type-tag"/>
          <xul:label class="ac-normal-text ac-comment" xbl:inherits="selected" value=":"/>
          <xul:description anonid="extra" class="ac-normal-text ac-comment" xbl:inherits="selected"/>
        </xul:hbox>
        <xul:image anonid="type-image" class="ac-type-icon"/>
      </xul:hbox>
    </content>
    <implementation implements="nsIDOMXULSelectControlItemElement">
      <constructor>
        <![CDATA[
            this._typeImage = document.getAnonymousElementByAttribute(this, "anonid", "type-image");

            this._titleBox = document.getAnonymousElementByAttribute(this, "anonid", "title-box");
            this._title = document.getAnonymousElementByAttribute(this, "anonid", "title");

            this._extraBox = document.getAnonymousElementByAttribute(this, "anonid", "extra-box");
            this._extra = document.getAnonymousElementByAttribute(this, "anonid", "extra");

            this._adjustAcItem();
          ]]>
      </constructor>

      <property name="label" readonly="true">
        <getter>
          <![CDATA[
            var title = this.getAttribute("title");
            var url = this.getAttribute("url");
            var panel = this.parentNode.parentNode;

            // allow consumers that have extended popups to override
            // the label values for the richlistitems
            if (panel.createResultLabel)
              return panel.createResultLabel(title, url, this.getAttribute("type"));

            // aType (ex: "ac-result-type-<aType>") is related to the class of the image,
            // and is not "visible" text so don't use it for the label (for accessibility).
            return title + " " + url;
          ]]>
        </getter>
      </property>


      <method name="_getBoundaryIndices">
        <parameter name="aText"/>
        <parameter name="aSearchTokens"/>
        <body>
          <![CDATA[
          // Short circuit for empty search ([""] == "")
          if (aSearchTokens == "")
            return [0, aText.length];

          // Find which regions of text match the search terms
          let regions = [];
          for each (let search in aSearchTokens) {
            let matchIndex;
            let startIndex = 0;
            let searchLen = search.length;

            // Find all matches of the search terms, but stop early for perf
            let lowerText = aText.toLowerCase().substr(0, this.boundaryCutoff);
            while ((matchIndex = lowerText.indexOf(search, startIndex)) >= 0) {
              // Start the next search from where this one finished
              startIndex = matchIndex + searchLen;
              regions.push([matchIndex, startIndex]);
            }
          }

          // Sort the regions by start position then end position
          regions = regions.sort(function(a, b) let (start = a[0] - b[0])
            start == 0 ? a[1] - b[1] : start);

          // Generate the boundary indices from each region
          let start = 0;
          let end = 0;
          let boundaries = [];
          let len = regions.length;
          for (let i = 0; i < len; i++) {
            // We have a new boundary if the start of the next is past the end
            let region = regions[i];
            if (region[0] > end) {
              // First index is the beginning of match
              boundaries.push(start);
              // Second index is the beginning of non-match
              boundaries.push(end);

              // Track the new region now that we've stored the previous one
              start = region[0];
            }

            // Push back the end index for the current or new region
            end = Math.max(end, region[1]);
          }

          // Add the last region
          boundaries.push(start);
          boundaries.push(end);

          // Put on the end boundary if necessary
          if (end < aText.length)
            boundaries.push(aText.length);

          // Skip the first item because it's always 0
          return boundaries.slice(1);
          ]]>
        </body>
      </method>

      <method name="_getSearchTokens">
        <parameter name="aSearch"/>
        <body>
          <![CDATA[
          let search = aSearch.toLowerCase();
		  search = search.split(/\s+/)
		  search.shift()
          return search;
          ]]>
        </body>
      </method>

      <method name="_setUpDescription">
        <parameter name="aDescriptionElement"/>
        <parameter name="aText"/>
        <parameter name="aNoEmphasis"/>
        <body>
          <![CDATA[
          // Get rid of all previous text
          while (aDescriptionElement.hasChildNodes())
            aDescriptionElement.removeChild(aDescriptionElement.firstChild);

          
          // Get the indices that separate match and non-match text
          let search = this.getAttribute("text");
          let tokens = this._getSearchTokens(search);
          let indices = this._getBoundaryIndices(aText, tokens);

          // If we're searching for something that needs alternate emphasis,
          // we'll need to check the text that we match
          //let checkAlt = this._needsAlternateEmphasis(search);

          let next;
          let start = 0;
          let len = indices.length;
          // Even indexed boundaries are matches, so skip the 0th if it's empty
          for (let i = indices[0] == 0 ? 1 : 0; i < len; i++) {
            next = indices[i];
            let text = aText.substr(start, next - start);
            start = next;

            if (i % 2 == 0) {
              // Emphasize the text for even indices
              let span = aDescriptionElement.appendChild(
                document.createElementNS("http://www.w3.org/1999/xhtml", "span"));
              span.className = "InstantFoxSuggest ac-emphasize-text";
              span.textContent = text;
            } else {
              // Otherwise, it's plain text
              aDescriptionElement.appendChild(document.createTextNode(text));
            }
          }
          ]]>
        </body>
      </method>

      <method name="_adjustAcItem">
        <body>
          <![CDATA[
          var url = this.getAttribute("url");
          var title = this.getAttribute("title");
          var type = this.getAttribute("type");

		  this._setUpDescription(this._title, title);
		  return;
          ]]>
        </body>
      </method>


    </implementation>
  </binding>
</bindings>