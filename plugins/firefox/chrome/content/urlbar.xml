<?xml version="1.0" encoding="UTF-8"?>

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="urlbar" extends="chrome://browser/content/urlbarBindings.xml#urlbar">
    <content sizetopopup="pref">
      <xul:hbox anonid="textbox-container"
                class="autocomplete-textbox-container urlbar-textbox-container"
                flex="1" xbl:inherits="focused">
        <children includes="image|deck|stack|box">
          <xul:image class="autocomplete-icon" allowevents="true"/>
        </children>
		<xul:stack flex="1">
			<xul:hbox class="instantfox-box">
			  <xul:hbox anonid="instantFoxKey" class="instantfox-key"/>		
			  <xul:hbox anonid="instantFoxSpacer" class="instantfox-spacer"/>		
			  <xul:hbox anonid="instantFoxShaddow" class="instantfox-shaddow" />
			</xul:hbox>
			<xul:hbox class='instantfox-tip'  bottom='0'  right='0'/>
			<xul:hbox anonid="textbox-input-box"
					  class="textbox-input-box urlbar-input-box"
					  flex="1" xbl:inherits="tooltiptext=inputtooltiptext">
			  <children/>
			  <html:input anonid="input"
						  class="autocomplete-textbox urlbar-input textbox-input uri-element-right-align"
						  allowevents="true"
						  xbl:inherits="tooltiptext=inputtooltiptext,onfocus,onblur,value,type,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey"/>
			</xul:hbox>
		</xul:stack>
        <children includes="hbox"/>
      </xul:hbox>
      <xul:dropmarker anonid="historydropmarker"
                      class="autocomplete-history-dropmarker urlbar-history-dropmarker"
                      allowevents="true"
                      xbl:inherits="open,enablehistory,parentfocused=focused"/>
      <xul:popupset anonid="popupset"
                    class="autocomplete-result-popupset"/>
      <children includes="toolbarbutton"/>
    </content>
	
    <implementation implements="nsIDOMEventListener, nsIObserver">

      <field name="uri"/>
      <field name="_focused"/>
      <field name="_mouseover"/>
      <field name="_iconWasHovered"/>
      <field name="_tooltipTimer"/>
	  
      <field name="inputBox">
        document.getAnonymousElementByAttribute(this, "anonid", "textbox-input-box");
      </field>
      <field name="inputBoxInner">
        document.getAnonymousElementByAttribute(this, "anonid", "textbox-input-box-inner");
      </field>
	  
	  <field name="instantFoxShaddowNode">
        document.getAnonymousElementByAttribute(this, "anonid", "instantFoxShaddow");
      </field>  
	  <field name="instantFoxSpacerNode">
        document.getAnonymousElementByAttribute(this, "anonid", "instantFoxSpacer");
      </field> 
	  <field name="instantFoxKeyNode">
        document.getAnonymousElementByAttribute(this, "anonid", "instantFoxKey");
      </field> 
	  <field name="tip">
        document.getAnonymousElementByAttribute(this, "class", "instantfox-tip");
      </field>  

	  <method name="showTip">
        <parameter name="aURL"/>
        <body><![CDATA[
			this.tip.hidden=false
			this.tip.textContent = aURL;
        ]]></body>
      </method> 
	  
	  <method name="InsertShaddowLink">
        <parameter name="aURL"/>
        <body><![CDATA[
			//if(aURL){
			this.instantFoxShaddowNode.textContent = aURL;
			//}
        ]]></body>
      </method> 
	  <method name="InsertSpacerLink">
        <parameter name="aURL"/>
        <body><![CDATA[
			if(!aURL){aURL='';this.tip.hidden=true}
			var i = aURL.indexOf(' ')
			this.instantFoxKeyNode.textContent = aURL.substring(0,i)
			this.instantFoxSpacerNode.textContent = aURL.substr(i);
			
        ]]></body>
      </method> 
	  <method name="InsertShaddowStyle">
        <parameter name="px"/>
        <body><![CDATA[return
			if(px){
				this.instantFoxShaddowNode.style.cssText += "margin: "+px+" !important;";
			}
        ]]></body>
      </method>
	  <method name="InsertShaddowStyleStart">
        <parameter name="start"/>
        <body><![CDATA[return
			if(start){
				this.instantFoxShaddowNode.style.cssText += "-moz-margin-start:  "+start+" !important;";
			}
        ]]></body>
      </method>        
    </implementation>

  </binding>


  <binding id="autocomplete-richlistitem" extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">
    <content>
      <xul:hbox align="center" class="ac-title-box">
        <xul:image xbl:inherits="src=image" class="ac-site-icon"/>
        <xul:hbox anonid="title-box" class="ac-title" flex="1"
                  onunderflow="_doUnderflow('_title');"
                  onoverflow="_doOverflow('_title');">
          <xul:description anonid="title" class="ac-normal-text ac-comment" xbl:inherits="selected"/>
        </xul:hbox>
        <xul:hbox anonid="extra-box" class="ac-extra" align="center" hidden="true">
          <xul:image class="ac-result-type-tag"/>
          <xul:label class="ac-normal-text ac-comment" xbl:inherits="selected" value=":"/>
          <xul:description anonid="extra" class="ac-normal-text ac-comment" xbl:inherits="selected"/>
        </xul:hbox>
        <xul:image anonid="type-image" class="ac-type-icon"/>
      </xul:hbox>
    </content>
    <implementation implements="nsIDOMXULSelectControlItemElement">
      <constructor>
        <![CDATA[
            this._typeImage = document.getAnonymousElementByAttribute(this, "anonid", "type-image");

            this._titleBox = document.getAnonymousElementByAttribute(this, "anonid", "title-box");
            this._title = document.getAnonymousElementByAttribute(this, "anonid", "title");

            this._extraBox = document.getAnonymousElementByAttribute(this, "anonid", "extra-box");
            this._extra = document.getAnonymousElementByAttribute(this, "anonid", "extra");

            this._adjustAcItem();
          ]]>
      </constructor>

      <property name="label" readonly="true">
        <getter>
          <![CDATA[
            var title = this.getAttribute("title");
            var url = this.getAttribute("url");
            var panel = this.parentNode.parentNode;

            // allow consumers that have extended popups to override
            // the label values for the richlistitems
            if (panel.createResultLabel)
              return panel.createResultLabel(title, url, this.getAttribute("type"));

            // aType (ex: "ac-result-type-<aType>") is related to the class of the image,
            // and is not "visible" text so don't use it for the label (for accessibility).
            return title + " " + url;
          ]]>
        </getter>
      </property>


      <method name="_getBoundaryIndices">
        <parameter name="aText"/>
        <parameter name="aSearchTokens"/>
        <body>
          <![CDATA[
          // Short circuit for empty search ([""] == "")
          if (aSearchTokens == "")
            return [0, aText.length];

          // Find which regions of text match the search terms
          let regions = [];
          for each (let search in aSearchTokens) {
            let matchIndex;
            let startIndex = 0;
            let searchLen = search.length;

            // Find all matches of the search terms, but stop early for perf
            let lowerText = aText.toLowerCase().substr(0, this.boundaryCutoff);
            while ((matchIndex = lowerText.indexOf(search, startIndex)) >= 0) {
              // Start the next search from where this one finished
              startIndex = matchIndex + searchLen;
              regions.push([matchIndex, startIndex]);
            }
          }

          // Sort the regions by start position then end position
          regions = regions.sort(function(a, b) let (start = a[0] - b[0])
            start == 0 ? a[1] - b[1] : start);

          // Generate the boundary indices from each region
          let start = 0;
          let end = 0;
          let boundaries = [];
          let len = regions.length;
          for (let i = 0; i < len; i++) {
            // We have a new boundary if the start of the next is past the end
            let region = regions[i];
            if (region[0] > end) {
              // First index is the beginning of match
              boundaries.push(start);
              // Second index is the beginning of non-match
              boundaries.push(end);

              // Track the new region now that we've stored the previous one
              start = region[0];
            }

            // Push back the end index for the current or new region
            end = Math.max(end, region[1]);
          }

          // Add the last region
          boundaries.push(start);
          boundaries.push(end);

          // Put on the end boundary if necessary
          if (end < aText.length)
            boundaries.push(aText.length);

          // Skip the first item because it's always 0
          return boundaries.slice(1);
          ]]>
        </body>
      </method>

      <method name="_getSearchTokens">
        <parameter name="aSearch"/>
        <body>
          <![CDATA[
          let search = aSearch.toLowerCase();
		  search = search.split(/\s+/)
		  search.shift()
          return search;
          ]]>
        </body>
      </method>

      <method name="_setUpDescription">
        <parameter name="aDescriptionElement"/>
        <parameter name="aText"/>
        <parameter name="aNoEmphasis"/>
        <body>
          <![CDATA[
          // Get rid of all previous text
          while (aDescriptionElement.hasChildNodes())
            aDescriptionElement.removeChild(aDescriptionElement.firstChild);

          
          // Get the indices that separate match and non-match text
          let search = this.getAttribute("text");
          let tokens = this._getSearchTokens(search);
          let indices = this._getBoundaryIndices(aText, tokens);

          // If we're searching for something that needs alternate emphasis,
          // we'll need to check the text that we match
          //let checkAlt = this._needsAlternateEmphasis(search);

          let next;
          let start = 0;
          let len = indices.length;
          // Even indexed boundaries are matches, so skip the 0th if it's empty
          for (let i = indices[0] == 0 ? 1 : 0; i < len; i++) {
            next = indices[i];
            let text = aText.substr(start, next - start);
            start = next;

            if (i % 2 == 0) {
              // Emphasize the text for even indices
              let span = aDescriptionElement.appendChild(
                document.createElementNS("http://www.w3.org/1999/xhtml", "span"));
              span.className = "InstantFoxSuggest ac-emphasize-text";
              span.textContent = text;
            } else {
              // Otherwise, it's plain text
              aDescriptionElement.appendChild(document.createTextNode(text));
            }
          }
          ]]>
        </body>
      </method>

      <method name="_adjustAcItem">
        <body>
          <![CDATA[
          var url = this.getAttribute("url");
          var title = this.getAttribute("title");
          var type = this.getAttribute("type");

		  this._setUpDescription(this._title, title);
		  return;
          ]]>
        </body>
      </method>


    </implementation>
	<handlers>
      <handler event="mouseup">
        <![CDATA[
		// todo: find why key is stripped from url and gURLBar.controller.getValueAt(gURLBar.popup.selectedIndex);
		var key = this.getAttribute("text").trim().split(' ')[0]
		var search = key + ' ' + this.getAttribute("url")

		InstantFox.HH.onEnter(search)
        event.preventDefault()
		event.stopPropagation()
      ]]>
      </handler>
    </handlers>
  </binding>
</bindings>